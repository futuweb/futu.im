---
title: HTTPS自建CA及自签名证书不完全指南（理论篇）
date: 2017-07-17 18:00
category: 网络安全
tags: [OpenSSL,HTTPS,Node.js,nginx]
author: Jin
---

HTTPS 全称 HTTP over SSL，即工作于SSL层之上的HTTP协议。它对开发者和使用者是透明的，只是数据传输部分是加密的。

SSL分为 1.0 / 2.0 / 3.0 等很多版本，随着时间的推移，它也变得越来越不安全，因此现在我们通常使用更安全的 TLS 协议。TLS 协议也有不同版本，目前最新最安全的是 TLS 1.2 。一般情况下，我们不会具体区别 SSL 和 TLS，现在很多场合提到的 SSL 其实也是 TLS 协议。

## HTTPS安全浏览

![https-demo](/images/2017-07-17-https-certificate/demo.png)

如果我们正在浏览的网页是安全的 HTTPS 网页，则大部分浏览器会显示一把绿色的锁，表示这是加密的连接，且通信过程是安全的。

而要让浏览器认为这个网页是安全的，则需要满足以下几个条件：

1. HTTPS 协议访问
2. 服务端出具的证书内容正确（域名、签名方式等正确）
3. 服务端出具的证书由 CA（数字证书中心） 签发
4. 签发证书的 CA 在浏览器（或操作系统）的受信任列表中

所谓的 CA（数字证书中心）一般是一个机构，它们被内置在浏览器或操作系统的受信任列表中。一个证书只有被 CA 签名过（也叫由 CA 签发的证书），浏览器才可能在受信任列表中找到它对应的 CA ，然后判断是否应该信任这个证书。

> 事实上第3点和第4点并不完全准确，如果一个证书不是由 CA 签发的，但是存在于浏览器（或操作系统）的受信任列表中，那么它事实上相当于一个CA的根证书，也会被认为是安全的。
> 
> 但是，在实际操作中，几乎没有这样的案例，因为几乎没有 CA 会直接拿自己的根证书来让某个网站使用。

<!-- more -->

## HTTPS服务器的搭建

在 Node.js 中配置一个 HTTPS 服务器非常简单。Node.js底层引入了OpenSSL开源库，并直接提供了`https`模块：

```javascript
// 引入https模块
const https = require('https');
const fs = require('fs');

// 创建HTTPS服务需要私钥和证书文件
let options = {
  key: fs.readFileSync('./server.key'), //私钥
  cert: fs.readFileSync('./server.crt') //数字证书
};

// 创建HTTPS服务器
https.createServer(options , (req , res)=>{
  res.writeHead(200);
  res.end('https is working');
}).listen(443);
```

可以发现创建https服务器比我们熟悉的创建http服务器要多一个`options`参数。`options`里面包含的是https服务器的私钥和数字证书。

如果使用`nginx`来创建https服务器，则可能是这样：

```
server
{
    listen 443 ssl;
    server_name  ssltest.com;
    index index.html index.htm;
    root /data/ssltest;

    ssl_certificate /data/ssltest.crt;
    ssl_certificate_key     /data/ssltest.key;

}
```

同样，在上方的配置文件中，需要使用`ssl_certificate_key`和`ssl_certificate`来指定私钥和数字证书。

问题来了：私钥和数字证书分别是什么？

## 科普：HTTPS相关知识

本文将介绍一些与我们接下来生成证书相关的知识。为了简单起见，有一些和实际操作关系不大的、理论性比较强的内容忽略不计。

### HTTPS是如何通信的？

我们都知道HTTPS是加密通信的，但是对于具体的过程，却并不是人人都知道。事实上，HTTPS的通信过程，大致上可以分为握手（非对称加密）和通信（对称加密）两个过程。

握手的部分是使用非对称加密的。既然是非对称加密，就会涉及到公钥、私钥的问题。在经典的非对称加密体系中，公钥用来加密，私钥用来签名，也即如果A同学要向B同学发一个加密信息，那么A同学必须拥有B同学的公钥。同理，如果B同学也要向A同学发加密信息，他也必须拥有A同学的私钥。

在HTTPS中，也是同样的情况，如果双向通信都需要加密的话，那么服务端和客户端各需要一套密钥（私钥+公钥）。而事实上，在握手的部分，客户端的密钥是可选的，常见的HTTPS通信中都没有客户端密钥的参与。那这个过程具体是怎样的呢？

1. 客户端向服务端打个招呼，并告诉服务端，自己要访问哪个域名（SNI），这一步是不加密的
2. 服务端向客户端打招呼，出示自己的证书，同时证书中包含了服务端的公钥，这一步也是不加密的
3. 客户端验证服务端的证书是否合法，如果不合法就中止请求并报错
4. 客户端生成一个后续使用密钥（用于对称加密），使用服务端的公钥对这个密钥进行加密，发送到服务端
5. 服务端对上一步客户端发来的加密消息进行解密并验证

接下来，就使用对称加密来通信了。

![https-demo](/images/2017-07-17-https-certificate/steps.png)

### 如何确定通信是安全的

在这个过程中涉及到很多我们接下来会接触到的知识点。

首先，服务端用于加密通信的私钥和公钥都是由自己生成的，稍后我们将看到具体的生成方式。但是，我们从一开始到现在出现过很多次的所谓“证书”是什么呢？以及客户端又是如何验证这个证书是否合法的呢？

我们可以想象一下，如果在客户端和服务端中间，存在一个中间人，就像代理一样。对于客户端来说，它是服务端，对于服务端来说，它又是客户端。这样它就可以两边同时通信，直接窃听整个通信过程，这样我们的加密就毫无意义了。因此必须要有一种机制，来防止中间人攻击。而证书正是这样一种身份验证的机制。

![https-demo](/images/2017-07-17-https-certificate/mith.jpg)

具体而言，证书大约等于“公钥+身份+签名”三部分。身份主要就是服务器的相关信息，其中一个非常重要的信息就是域名。而签名的过程则是数字证书中心（CA）对身份表示认可，然后使用自己的私钥对这个身份进行签署，表示“我（CA）证明，这个身份是真的”。

那CA又是什么东西呢？它其实就是一些内置在操作系统（浏览器）信任列表中的一些机构，每个机构都拥有自己的根证书，这些证书被操作系统（浏览器）无条件信任。当一个证书被CA签署后，操作系统（浏览器）就会信任这个证书所代表的身份。

CA在签署证书的时候，都会做一些真实性验证，保证只有真实的网站拥有者才可以被签署。因此，当浏览器拿到一个被CA签署过的证书的时候，只要看一下这个CA是不是在信任列表中，就可以决定是否信任这个证书了。

所以这就有了防中间人攻击的关键点：合法的证书是无法伪造的。如果中间人替换了这个证书，浏览器就不会信任这次握手，将中止通信。

那么，在不替换证书的前提下，为什么中间人就无法拦截通信了呢？这是因为证书中包含了服务器的公钥，客户端会使用这个公钥加密信息，而这个信息只有拥有私钥的人才可以解密。很显然，只有真实的服务器才有这个私钥，因此中间人是无法解密了。

## 小结

至此，我们比较详细地了解了HTTPS的通信过程以及安全机制。中间涉及到了私钥、公钥、CA、签名等比较重要的概念。下一篇中，我们将看到如何使用OpenSSL进行自签名证书。